# 常见问题

本文档记录开发过程中遇到的问题和解决方案。

---

## 🔧 编译相关问题

### Q1: Gradle版本不兼容

**现象**:
````
The minimum compatible Gradle version is 8.5.
````

**解决方案**:

1. **修改gradle-wrapper.properties**:
   ````properties
   distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
   ````

2. **修改build.gradle (根目录)**:
   ````gradle
   classpath 'com.android.tools.build:gradle:8.13.1'
   ````

3. **重新同步**:
   ````bash
   ./gradlew --stop
   ./gradlew assembleDebug
   ````

---

### Q2: 找不到Java环境

**现象**:
````
Unable to locate a Java Runtime.
````

**解决方案**:

设置JAVA_HOME环境变量:
````bash
export JAVA_HOME="/Applications/Android Studio.app/Contents/jbr/Contents/Home"
./gradlew assembleDebug
````

---

### Q3: gradle-wrapper.jar损坏

**现象**:
````
ClassNotFoundException: org.gradle.wrapper.GradleWrapperMain
````

**原因**: gradle-wrapper.jar文件损坏或不完整

**解决方案**:

重新下载wrapper:
````bash
curl -L -o gradle/wrapper/gradle-wrapper.jar \
  https://raw.githubusercontent.com/gradle/gradle/master/gradle/wrapper/gradle-wrapper.jar
````

---

### Q4: 缺少应用图标

**现象**:
````
error: resource mipmap/ic_launcher not found
````

**解决方案**:

使用ImageMagick生成图标:
````bash
# 创建mipmap目录
mkdir -p app/src/main/res/mipmap-{mdpi,hdpi,xhdpi,xxhdpi,xxxhdpi}

# 生成不同尺寸的图标
convert -size 48x48 xc:#4CAF50 -gravity center -pointsize 24 \
  -fill white -annotate +0+0 "W" app/src/main/res/mipmap-mdpi/ic_launcher.png

convert -size 72x72 xc:#4CAF50 -gravity center -pointsize 36 \
  -fill white -annotate +0+0 "W" app/src/main/res/mipmap-hdpi/ic_launcher.png

convert -size 96x96 xc:#4CAF50 -gravity center -pointsize 48 \
  -fill white -annotate +0+0 "W" app/src/main/res/mipmap-xhdpi/ic_launcher.png

convert -size 144x144 xc:#4CAF50 -gravity center -pointsize 72 \
  -fill white -annotate +0+0 "W" app/src/main/res/mipmap-xxhdpi/ic_launcher.png

convert -size 192x192 xc:#4CAF50 -gravity center -pointsize 96 \
  -fill white -annotate +0+0 "W" app/src/main/res/mipmap-xxxhdpi/ic_launcher.png

# 复制为round图标
for dir in mdpi hdpi xhdpi xxhdpi xxxhdpi; do
  cp app/src/main/res/mipmap-$dir/ic_launcher.png \
     app/src/main/res/mipmap-$dir/ic_launcher_round.png
done
````

---

## 📱 真机连接问题

### Q5: 无法连接真机

**现象**:
````
adb devices
List of devices attached
(空)
````

**解决方案**:

#### 方法1: 无线ADB (推荐)

1. **手机端设置**:
   ````
   设置 -> 系统 -> 开发者选项 -> 无线调试 (打开)
   ````

2. **首次配对** (只需一次):
   ````bash
   # 手机上点击"使用配对码配对设备"
   # 记下配对码、IP和端口
   adb pair 192.168.1.3:37859
   # 输入配对码
   ````

3. **日常连接**:
   ````bash
   adb connect 192.168.1.3:41239
   ````

#### 方法2: USB连接

1. 开启USB调试
2. 连接数据线
3. 手机上允许USB调试

---

### Q6: 连接后无法安装

**现象**:
````
adb: failed to install: Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE]
````

**解决方案**:

卸载旧版本后重新安装:
````bash
adb -s 192.168.1.3:41239 uninstall com.wechat.auto
adb -s 192.168.1.3:41239 install -r app/build/outputs/apk/debug/app-debug.apk
````

---

## 🐛 功能问题

### Q7: 点击按钮没反应

**现象**: 点击"启动自动化任务"按钮,没有任何反应

**可能原因**:

1. **按钮被禁用**
   - 检查无障碍服务是否已开启
   - 状态应显示 ✅

2. **无障碍服务未运行**
   - 重新开启无障碍服务
   - 杀掉应用重新打开

**解决方案**:

````bash
# 查看日志
adb -s 192.168.1.3:41239 logcat | grep -E "MainActivity|WeChatAutoService"
````

---

### Q8: 提示"任务已启动"但微信没打开

**现象**: Toast显示"自动化任务已启动",但微信没有打开

**原因**: 启动微信的Intent配置错误

**解决方案**:

使用ComponentName直接指定Activity:
````java
Intent intent = new Intent();
intent.setComponent(new ComponentName(
    "com.tencent.mm",
    "com.tencent.mm.ui.LauncherUI"
));
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
startActivity(intent);
````

**验证微信包名**:
````bash
adb shell pm list packages | grep tencent
# 应该看到: package:com.tencent.mm
````

---

### Q9: 无障碍服务无法开启

**现象**: 在设置中找不到WeChatAuto,或者开关无法打开

**解决方案**:

1. **检查配置文件**:
   - `AndroidManifest.xml`中是否声明了服务
   - `accessibility_service_config.xml`是否存在

2. **重新安装应用**:
   ````bash
   adb uninstall com.wechat.auto
   adb install app-debug.apk
   ````

3. **重启手机**

---

### Q10: 无障碍服务频繁断开

**现象**: 无障碍服务自动关闭

**可能原因**:
- 系统省电策略
- 内存不足被杀

**解决方案**:

1. **关闭省电限制**:
   ````
   设置 -> 电池 -> WeChatAuto -> 无限制
   ````

2. **锁定后台**:
   ````
   最近任务 -> WeChatAuto -> 锁定
   ````

3. **添加到白名单**:
   ````
   设置 -> 应用管理 -> WeChatAuto -> 自启动 (允许)
   ````

---

## � 通讯录同步问题

### Q11: 同步的好友数量不全

**现象**: 同步显示540个好友,但实际有600+个好友

**原因**:
1. **最大滚动次数限制** - 之前设置为50次,滚动到50次就停止了
2. **滚动太快** - 列表加载不及时,导致读取重复数据
3. **等待时间不够** - 滚动后没有足够时间让列表加载

**解决方案**:

✅ **已优化** (V0.3.1):
- 最大滚动次数: 50次 → 500次
- 滚动时长: 500ms → 800ms
- 等待时间: 1000ms → 1500ms
- 停止判断: 连续3次无新好友 → 连续5次无新好友

**验证方法**:
```bash
# 查看同步日志
adb -s 192.168.1.3:37139 logcat | grep "WeChatAutoService"

# 应该看到类似日志:
# 第1次读取: 本次找到18个好友, 新增18个, 总计18个
# 第2次读取: 本次找到26个好友, 新增10个, 总计28个
# ...
# 第N次读取: 本次找到26个好友, 新增0个, 总计XXX个
# 连续5次没有新好友
# 已到达列表底部
```

---

### Q12: 点击"配置自动化任务"闪退

**现象**:
```
java.lang.ClassCastException: java.lang.String cannot be cast to java.util.Set
```

**原因**:
- 旧版本使用`StringSet`存储好友列表
- 新版本使用JSON字符串存储
- 读取时类型不匹配导致崩溃

**解决方案**:

✅ **已修复** (V0.3.1):
```java
// 兼容性读取逻辑
String friendsJson = prefs.getString("friends_list", null);
if (friendsJson != null) {
    // 新格式: JSON字符串
    parseJsonFriends(friendsJson);
} else {
    // 旧格式: StringSet
    Set<String> friendsSet = prefs.getStringSet("friends_list", null);
    if (friendsSet != null) {
        // 自动转换为新格式
        convertToJsonFormat(friendsSet);
    }
}
```

**临时解决方案**:
```bash
# 清除应用数据
adb -s 192.168.1.3:37139 shell pm clear com.wechat.auto

# 重新同步通讯录
```

---

### Q13: 好友列表顺序混乱

**现象**: 每次打开好友列表,顺序都不一样

**原因**:
- `HashSet`无序
- `StringSet`无序
- 没有排序逻辑

**解决方案**:

✅ **已修复** (V0.3.0):
- 使用JSON字符串存储,保持顺序
- 按首字母排序(字母在前,特殊符号在后)
- 模仿微信的排序规则

**排序规则**:
1. 字母开头的在前 (A-Z, a-z)
2. 中文在中间 (按拼音首字母)
3. 特殊符号在后 (#, @, 等)

---

## �🔍 调试技巧

### 查看实时日志

````bash
# 清空日志
adb -s 192.168.1.3:41239 logcat -c

# 查看应用日志
adb -s 192.168.1.3:41239 logcat | grep -E "WeChatAuto|com.wechat.auto"

# 只看错误
adb -s 192.168.1.3:41239 logcat *:E | grep WeChatAuto
````

---

### 查看应用信息

````bash
# 检查应用是否安装
adb shell pm list packages | grep wechat.auto

# 查看应用详细信息
adb shell dumpsys package com.wechat.auto

# 查看应用权限
adb shell dumpsys package com.wechat.auto | grep permission
````

---

### 手动启动应用

````bash
# 启动主Activity
adb shell am start -n com.wechat.auto/.MainActivity

# 启动微信
adb shell am start -n com.tencent.mm/.ui.LauncherUI
````

---

## 💡 开发建议

### 1. 保持日志输出

在关键位置添加Log:
````java
Log.d(TAG, "关键操作: " + 详细信息);
Log.e(TAG, "错误信息: " + e.getMessage(), e);
````

### 2. 使用Toast反馈

让用户知道操作结果:
````java
Toast.makeText(this, "操作成功", Toast.LENGTH_SHORT).show();
````

### 3. 异常处理

所有可能出错的地方都要try-catch:
````java
try {
    // 可能出错的代码
} catch (Exception e) {
    Log.e(TAG, "操作失败", e);
    Toast.makeText(this, "操作失败: " + e.getMessage(), Toast.LENGTH_LONG).show();
}
````

### 4. 快速迭代

利用命令行编译,实现秒级迭代:
````bash
# 一条命令完成编译和安装
export JAVA_HOME="/Applications/Android Studio.app/Contents/jbr/Contents/Home" && \
./gradlew assembleDebug && \
adb -s 192.168.1.3:41239 install -r app/build/outputs/apk/debug/app-debug.apk
````

---

## 🚀 自动发送消息相关问题

### Q15: 搜索按钮定位不准确

**现象**:
点击"搜索"后,打开的不是右上角的搜索框,而是其他搜索功能。

**原因**:
使用`findAccessibilityNodeInfosByText("搜索")`查找,可能匹配到多个搜索按钮。

**解决方案**:

使用resource-id精确定位:
````java
// 方法1: 通过resource-id查找 (推荐)
List<AccessibilityNodeInfo> nodes = rootNode.findAccessibilityNodeInfosByViewId("com.tencent.mm:id/jha");

// 方法2: 通过content-desc查找
nodes = rootNode.findAccessibilityNodeInfosByText("搜索");
for (AccessibilityNodeInfo node : nodes) {
    if ("搜索".equals(node.getContentDescription()) && node.isClickable()) {
        node.performAction(AccessibilityNodeInfo.ACTION_CLICK);
        break;
    }
}
````

**关键点**:
- 优先使用resource-id,最精确
- 使用content-desc作为备选方案
- 避免仅通过text查找,容易误匹配

---

### Q16: 输入框冲突问题

**现象**:
在搜索框输入好友名后,立即被消息内容覆盖。

**原因**:
搜索框和聊天输入框都是EditText,使用第一个EditText会定位到搜索框。

**解决方案**:

使用最后一个EditText作为聊天输入框:
````java
private void sendTextMessage(String text) {
    List<AccessibilityNodeInfo> editTexts = findNodesByClassName(rootNode, "android.widget.EditText");

    if (editTexts.isEmpty()) {
        Log.e(TAG, "未找到输入框");
        return;
    }

    // 使用最后一个EditText (聊天输入框在底部)
    AccessibilityNodeInfo chatEditText = editTexts.get(editTexts.size() - 1);

    // 先获取焦点
    chatEditText.performAction(AccessibilityNodeInfo.ACTION_FOCUS);

    // 延迟后输入文字
    handler.postDelayed(() -> {
        Bundle arguments = new Bundle();
        arguments.putCharSequence(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, text);
        chatEditText.performAction(AccessibilityNodeInfo.ACTION_SET_TEXT, arguments);
    }, 500);
}
````

**关键点**:
- 聊天输入框在屏幕底部,是最后一个EditText
- 搜索框在顶部,是第一个EditText
- 先获取焦点,再延迟输入,确保输入成功

---

### Q17: 发送按钮点击失败

**现象**:
文字输入成功,但没有点击发送按钮,消息未发送。

**原因**:
通过text="发送"查找,但没有验证文字完全匹配,可能匹配到其他包含"发送"的按钮。

**解决方案**:

使用resource-id和精确文字匹配:
````java
private void clickSendButton() {
    AccessibilityNodeInfo rootNode = getRootInActiveWindow();
    if (rootNode == null) {
        Log.e(TAG, "无法获取根节点");
        return;
    }

    // 方法1: 通过resource-id查找 (推荐)
    List<AccessibilityNodeInfo> nodes = rootNode.findAccessibilityNodeInfosByViewId("com.tencent.mm:id/bql");
    if (nodes != null && !nodes.isEmpty()) {
        for (AccessibilityNodeInfo node : nodes) {
            if (node.isClickable() && "android.widget.Button".equals(node.getClassName())) {
                node.performAction(AccessibilityNodeInfo.ACTION_CLICK);
                Log.d(TAG, "点击发送按钮成功 (通过resource-id)");
                return;
            }
        }
    }

    // 方法2: 通过text查找 (备选)
    nodes = rootNode.findAccessibilityNodeInfosByText("发送");
    if (nodes != null && !nodes.isEmpty()) {
        for (AccessibilityNodeInfo node : nodes) {
            CharSequence text = node.getText();
            // 精确匹配文字
            if (text != null && "发送".equals(text.toString()) && node.isClickable()) {
                node.performAction(AccessibilityNodeInfo.ACTION_CLICK);
                Log.d(TAG, "点击发送按钮成功 (通过text)");
                return;
            }
        }
    }

    Log.w(TAG, "未找到发送按钮");
}
````

**关键点**:
- 优先使用resource-id: `com.tencent.mm:id/bql`
- 验证className是Button
- 精确匹配文字: `"发送".equals(text.toString())`
- 不要使用`contains("发送")`,会误匹配

---

### Q18: 时间延迟设置不当

**现象**:
操作执行过快,UI还没加载完成就开始下一步操作,导致失败。

**原因**:
不同步骤的UI加载时间不同,需要根据实际情况调整延迟。

**解决方案**:

根据UI加载时间设置合理延迟:

| 步骤 | 延迟时间 | 说明 |
|------|---------|------|
| 打开微信 → 点击搜索 | 1000ms | 等待微信主界面加载 |
| 点击搜索 → 输入好友名 | 2500ms | 等待搜索界面打开 |
| 输入好友名 → 点击结果 | 4000ms | 等待搜索结果出现 |
| 点击结果 → 发送消息 | **6000ms** | **关键**:等待聊天界面完全加载 |
| 输入文字 → 点击发送 | 800ms | 等待文字输入完成 |
| 发送消息 → 下一条消息 | 1000ms | 等待消息发送完成 |

**关键点**:
- 聊天界面加载最慢,需要6秒延迟
- 搜索结果出现需要4秒
- 不要设置太短,宁可多等一会
- 可以根据实际测试调整

---

### Q19: 如何调试UI定位问题

**问题**:
不知道某个按钮的resource-id或content-desc是什么。

**解决方案**:

使用adb命令导出UI结构:
````bash
# 1. 导出UI结构到手机
adb -s 192.168.1.3:40099 shell uiautomator dump /sdcard/ui.xml

# 2. 拉取到电脑
adb -s 192.168.1.3:40099 pull /sdcard/ui.xml /tmp/ui.xml

# 3. 查看UI结构
cat /tmp/ui.xml
````

**查找关键信息**:
````xml
<node
    text="发送"
    resource-id="com.tencent.mm:id/bql"
    class="android.widget.Button"
    content-desc=""
    clickable="true"
    bounds="[598,1518][706,1598]"
/>
````

**关键属性**:
- `resource-id`: 最精确的定位方式
- `content-desc`: 无障碍描述,适合图标按钮
- `text`: 文字内容,适合文字按钮
- `class`: 控件类型,用于过滤
- `clickable`: 是否可点击
- `bounds`: 坐标位置(不推荐使用)

---

## 📚 相关文档

- [开发指南](./开发指南.md) - 开发流程和规范
- [自动化文档](./自动化文档.md) - 技术实现详解
- [README](../README.md) - 项目总览

---

[返回README](../README.md)
